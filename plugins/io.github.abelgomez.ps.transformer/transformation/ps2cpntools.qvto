import stringutils;
import umlsupport;
import pssupport;
import cpnsupport;

modeltype UML "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype PS "strict" uses ps('http://io.github.abelgomez/ps/1.0');
modeltype CPN "strict" uses cpntools('http://io.github.abelgomez/cpntools/1.0');

transformation ps2cpntools(in uml : UML, out cpn : CPN);

main() {
	var cpnet := uml.interaction().map cpnet();
	-- Once the transformation has been executed, force the
	-- automatic layout of the CPNet for all its pages
	cpnet.binder.pages->forEach(p) {
		var nNodes := p.places->size() + p.transs->size(); 
		p.layout(nNodes * 40, nNodes * 40, 2000);
	}
		
}

mapping UML::Interaction::cpnet() : CPN::Cpnet {
	globbox := self.map invariantGlobbox();
	binder := object CPN::Binder {
		posx := 300;
		posy := 30;
		width := 500;
		height := 500;
		pages += self.map invariantPage();
		pages += self.map scenarioPage();
		pages += self.message[isSubscription()].subscription().map subscriptionPage();
	}
}

/**
	Declarations Section
**/

mapping UML::Interaction::invariantGlobbox() : CPN::Globbox {
	declarations += self.map priorities();
	declarations += self.map simpleColorSets();
	declarations += self.map compoundColorSets();
	declarations += self.map clientsCompoundColorSets();
	declarations += self.map values();
	declarations += self.map functions();
	declarations += self.map variables();
}

	
mapping UML::Interaction::priorities() : CPN::Block {
	idname := 'Standard priorities';
	declarations += object CPN::Ml { expression := 'val P1 = 10;'};
	declarations += object CPN::Ml { expression := 'val P2 = 20;'};
	declarations += object CPN::Ml { expression := 'val P3 = 30;'};
	declarations += object CPN::Ml { expression := 'val P4 = 40;'};
}

mapping UML::Interaction::simpleColorSets() : CPN::Block {
	idname := 'Standard simple declarations';
	declarations += map unit();
	declarations += map bool();
	declarations += map int();
	declarations += map real();
	declarations += map string();
	declarations += map lock();
}

mapping unit() : CPN::Unit { 
	idname := 'UNIT';
};

mapping bool() : CPN::Boolean {
	idname := 'BOOL';
};

mapping int() : CPN::Integer {
	idname := 'INT';
};

mapping real() : CPN::Real {
	idname := 'REAL';
};

mapping string() : CPN::String {
	idname := 'STRING';
};

mapping lock() : CPN::Unit {
	idname := 'LOCK';
};

mapping UML::Interaction::compoundColorSets() : CPN::Block {
	idname := 'Standard compound declarations';
	declarations += map intt();
	declarations += map rec();
	declarations += map cli();
	declarations += map cl();
	declarations += map ecli();
	declarations += map eclir();
};

mapping intt() : CPN::Alias {
	idname := 'INTT'; 
	timed := true; 
	simpleColors := resolveoneIn(int);
};

mapping rec() : CPN::Product {
	idname := 'REC';
	timed := true; 
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(int);
};

mapping cli() : CPN::Product {
	idname := 'CLI';
	timed := true; 
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
};

mapping cl() : CPN::Product {
	idname := 'CL';
	timed := true; 
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(int);
};

mapping ecli() : CPN::Product {
	idname := 'ECLI';
	timed := true; 
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
};

mapping eclir() : CPN::Product {
	idname := 'ECLIR';
	timed := true; 
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(string);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(real);
	simpleColors += resolveoneIn(int);
	simpleColors += resolveoneIn(string);
};

mapping UML::Interaction::clientsCompoundColorSets() : CPN::Block {
	idname := 'Clients declarations';
	declarations += self.clientClassifiers()->map clientProductDeclaration();
	declarations += self.clientClassifiers()->map clientVariableDeclaration();
	declarations += self.clientClassifiers().attribute->map clientPropertyVariablesDeclaration();
};

mapping UML::Classifier::clientProductDeclaration() : CPN::Product {
	idname := self.name.toUpper();
	simpleColors += resolveoneIn(string);
	self.attribute->forEach(p) {
		if (p.type.name = 'String') {
			simpleColors += resolveoneIn(string);
		} else if (p.type.name = 'Boolean') {
			simpleColors += resolveoneIn(bool);
		} else if (p.type.name = 'Integer') {
			simpleColors += resolveoneIn(int);
		} else if (p.type.name = 'Real') {
			simpleColors += resolveoneIn(real);
		} else {
			assert fatal (false) with log ('Unknown Client Classifier Property type: "{1}"'._format(p.type.name));
		};
	};
	timed := true;
};

mapping UML::Classifier::clientVariableDeclaration() : CPN::Var {
	idname :=  self.clientVarName();
	type := resolveoneIn(string);
};

mapping UML::Property::clientPropertyVariablesDeclaration() : CPN::Var {
	idname := self.name;
	if (self.type.name = 'String') {
		type := resolveoneIn(string);
	} else if (self.type.name = 'Boolean') {
		type := resolveoneIn(bool);
	} else if (self.type.name = 'Integer') {
		type := resolveoneIn(int);
	} else if (self.type.name = 'Real') {
		type := resolveoneIn(real);
	} else {
		assert fatal (false) with log ('Unknown Client Classifier Property type: "{1}"'._format(self.type.name));
	};
};

mapping UML::Interaction::values() : CPN::Block {
	idname := 'Value declarations';
	declarations += object CPN::Ml {
		expression := 'val m1 = 1';
	};
	declarations += object CPN::Ml {
		expression := 'val m2 = 1';
	};
	declarations += object CPN::Integer {
		idname := 'V0m1';
		_with += '0';
		_with += 'm1';
	};
	declarations += object CPN::Integer {
		idname := 'V0m2';
		_with += '0';
		_with += 'm2';
	};
	declarations += object CPN::Ml {
		var subscriptions : Collection(PS::Subscription) := uml.interaction().message->select(isSubscription()).subscription();
		var entries : List (String);
		subscriptions->forEach(s) {
			entries += '1`("{1}","{2}",{3},{4},{5},"{6}")@0'._format(s.client.base_Lifeline.represents.type.name, s.resource._tag, s.minValue, s.maxValue, s.subscriptionTime, s.triggers.name);
		};
		expression := entries->joinfields('++\n','val PosCli=',';');
	};
	declarations += object CPN::Ml {
		var resources : Collection(PS::Resource) := uml.interaction().resourcesLifelines().resource();
		var entries : List (String);
		resources->forEach(r) {
			entries += '1`({1},"{2}",{3},{4})@0'._format(r.epr, r._tag, r.value, r.time);
		};
		expression := entries->joinfields('++\n','val PosRec=',';');
	};
	declarations += object CPN::Ml {
		expression := 'val count=' +
			'2`1@0++2`1@1++1`1@2;';
	};
	declarations += object CPN::Ml {
		expression := 'val maxTime=4';
	};
};

mapping UML::Interaction::functions() : CPN::Block {
	idname := 'Function declarations';
	declarations += object CPN::Ml {
		expression := 'fun intTime()=IntInf.toInt(time());';
	};
	declarations += object CPN::Ml {
		expression := 'fun nT()=V0m1.ran();';
	};
};	

mapping UML::Interaction::variables() : CPN::Block {
	idname := 'Variable declarations';
	declarations += object CPN::Var {
		idname := 'l';
		type := resolveoneIn(lock);
	};
	declarations += object CPN::Var {
		idname := 'R';
		type := resolveoneIn(string);
	};
	declarations += object CPN::Var {
		idname := 'C';
		type := resolveoneIn(string);
	};
	declarations += object CPN::Var {
		idname := 'C1';
		type := resolveoneIn(string);
	};
	declarations += object CPN::Var {
		idname := 'tr';
		type := resolveoneIn(string);
	};
	declarations += object CPN::Var {
		idname := 'trOld';
		type := resolveoneIn(string);
	};
	declarations += object CPN::Var {
		idname := 'n';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'k';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'EPR';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'EPR1';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'v';
		type := resolveoneIn(real);
	};
	declarations += object CPN::Var {
		idname := 't';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'cr';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'condv1';
		type := resolveoneIn(real);
	};
	declarations += object CPN::Var {
		idname := 'condv11';
		type := resolveoneIn(real);
	};
	declarations += object CPN::Var {
		idname := 'condv2';
		type := resolveoneIn(real);
	};
	declarations += object CPN::Var {
		idname := 'condv22';
		type := resolveoneIn(real);
	};
	declarations += object CPN::Var {
		idname := 'condt';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'condtt';
		type := resolveoneIn(int);
	};
	declarations += object CPN::Var {
		idname := 'cc';
		type := resolveoneIn(int);
	};
};

mapping String::asRealVariable() {
	var varsBlock : CPN::Block := resolveoneIn(UML::Interaction::variables);
	varsBlock.declarations += object CPN::Var {
		idname := self;
		type := resolveoneIn(real);
	};
}

/**
	Pages
**/

mapping UML::Interaction::invariantPage() : CPN::Page {
	name := 'PS_Core_' + self.name;

	var pNotifications            := pNotifications(result);
	var pResourceRegistry         := pResourceRegistry(result);
	var pSubscriptionsRemoved     := create_place(result, 'Subscriptions\nRemoved', resolveoneIn(eclir));
	var pExpiredControl           := create_place(result, 'Expired\nControl', resolveoneIn(int));
	var pSubscriptionsTimeOut     := create_place(result, 'Subscriptions\nTime-Out', resolveoneIn(eclir));
	var pExpiredResources         := create_place(result, 'Expired\nResources', resolveoneIn(rec));
	var pTimeControl              := create_place(result, 'Time\nControl', resolveoneIn(intt), '0');
	var pOpControl                := create_place(result, 'Op\nControl', resolveoneIn(intt), 'count');
	var pSubscriptionRegistry     := create_place(result, 'Subscription\nRegistry', resolveoneIn(eclir));
	var pResources                := create_place(result, 'Resources', resolveoneIn(rec), 'PosRec');
	var pRoles                    := create_place(result, 'Roles', resolveoneIn(cli), 'PosCli');
	var pSubscriptionRequest      := create_place(result, 'Subscription\nRequest', resolveoneIn(ecli));
	var pFailSubscriptionRequests := create_place(result, 'Fail\nSubscription\nRequests', resolveoneIn(ecli));
	var pFailRoles                := create_place(result, 'Fail\nRoles', resolveoneIn(cli));

	var tEmpty                    := create_trans(result, 'Empty', 'P3');
	var tRemoveSubscription       := create_trans(result, 'Remove\nSubscription', 'P2', '[EPR = EPR1]');
	var tTimeStep                 := create_trans(result, 'Time\nStep', 'P4', '[n < maxTime]', '@+1');
	var tResourceExpire           := create_trans(result, 'Resource\nExpire', 'P2', '[n > cr]');
	var tGetTimeFail              := create_trans(result, 'Get Time\nFail', 'P4');
	var tSetPropFail              := create_trans(result, 'Set Prop\nFail', 'P4');
	var tGetPropFail              := create_trans(result, 'Get Prop\nFail', 'P4');
	var tSetTimeFail              := create_trans(result, 'Set Time\nFail', 'P4');
	var tSubscriptionTimeOut      := create_trans(result, 'Subscription\nTime-Out', 'P2', '[cc < n]');
	var tSetTime                  := create_trans(result, 'Set Time', 'P4');
	var tNotify                   := create_trans(result, 'Notify', 'P1', '[v <= condv2, v >= condv1]');
	var tPublishOk                := create_trans(result, 'Publish_ok', 'P4');
	var tPublishFail              := create_trans(result, 'Publish_fail', 'P2', '[EPR = EPR1]');
	var tDiscover                 := create_trans(result, 'Discover', 'P2');
	var tReSubscribe              := create_trans(result, 'Re-Subscribe', 'P2', '[C = C1]');
	var tFailDiscover             := create_trans(result, 'Fail\nDiscover', 'P4');
	var tFailSubscribe            := create_trans(result, 'Fail\nSubscribe', 'P4');
	var tSubscribe                := create_trans(result, 'Subscribe', 'P4');

	
	create_arc(result, pResourceRegistry, tNotify, '(EPR1,R,v,cr)');
	create_arc(result, tNotify, pResourceRegistry, '(EPR1,R,v,cr)');
	create_arc(result, tRemoveSubscription, pSubscriptionsRemoved, '(EPR1,R,C,condv1,condv2,cc,tr)');
	create_arc(result, pExpiredControl, tEmpty, 'EPR');
	create_arc(result, pExpiredControl, tRemoveSubscription, 'EPR');
	create_arc(result, tRemoveSubscription, pExpiredControl, 'EPR');
	create_arc(result, tResourceExpire, pExpiredControl, 'EPR');
	create_arc(result, tResourceExpire, pTimeControl, 'n');
	create_arc(result, pTimeControl, tResourceExpire, 'n');
	create_arc(result, pTimeControl, tTimeStep, 'n');
	create_arc(result, tTimeStep, pTimeControl, 'n + 1');
	create_arc(result, pTimeControl, tSubscriptionTimeOut, 'n');
	create_arc(result, tSubscriptionTimeOut, pTimeControl, 'n');
	create_arc(result, tSubscriptionTimeOut, pSubscriptionsTimeOut, '(EPR1,R,C,condv1,condv2,cc,tr)');
	create_arc(result, pSubscriptionRegistry, tSubscriptionTimeOut, '(EPR1,R,C,condv1,condv2,cc,tr)');
	create_arc(result, pSubscriptionRegistry, tRemoveSubscription, '(EPR1,R,C,condv1,condv2,cc,tr)');
	create_arc(result, pSubscriptionRegistry, tNotify, '(EPR1,R,C,condv1,condv2,cc,tr)');
	create_arc(result, pSubscriptionRegistry, tReSubscribe, '(EPR1,R,C,condv1,condv2,cc,trOld)');
	create_arc(result, tReSubscribe, pSubscriptionRegistry, '(EPR1,R,C,condv11,condv22,condtt+intTime(),tr)');
	create_arc(result, tSubscribe, pSubscriptionRegistry, '(EPR1,R,C,condv1,condv2,condt+intTime(),tr)');
	create_arc(result, tNotify, pNotifications, '(EPR1,R,C,v,cc)');
	create_arc(result, pResourceRegistry, tResourceExpire, '(EPR,R,v,cr)');
	create_arc(result, pResourceRegistry, tSetTime, '(EPR,R,v,cr)');
	create_arc(result, tSetTime, pResourceRegistry, '(EPR,R,v,nT()+intTime())');
	create_arc(result, tPublishOk, pResourceRegistry, '(EPR,R,v,intTime()+t)');
	create_arc(result, pResourceRegistry, tPublishFail, '(EPR1,R,v,cr)');
	create_arc(result, tPublishFail, pResourceRegistry, '(EPR1,R,v,cr)');
	create_arc(result, pResourceRegistry, tDiscover, '(EPR1,R,v,cr)');
	create_arc(result, tDiscover, pResourceRegistry, '(EPR1,R,v,cr)');
	create_arc(result, pResourceRegistry, tReSubscribe, '(EPR1,R,v,cr)');
	create_arc(result, tReSubscribe, pResourceRegistry, '(EPR1,R,v,cr)');
	create_arc(result, pResourceRegistry, tSubscribe, '(EPR1,R,v,cr)');
	create_arc(result, tSubscribe, pResourceRegistry, '(EPR1,R,v,cr)');
	create_arc(result, tDiscover, pSubscriptionRequest, '(EPR1,R,C,condv1,condv2,condt,tr)');
	create_arc(result, pSubscriptionRequest, tReSubscribe, '(EPR1,R,C,condv11,condv22,condtt,tr)');
	create_arc(result, pSubscriptionRequest, tSubscribe, '(EPR1,R,C,condv1,condv2,condt,tr)');
	create_arc(result, pSubscriptionRequest, tFailSubscribe, '(EPR1,R,C,condv1,condv2,condt,tr)');
	create_arc(result, tFailSubscribe, pFailSubscriptionRequests, '(EPR1,R,C,condv1,condv2,condt,tr)');
	create_arc(result, pRoles, tDiscover, '(C,R,condv1,condv2,condt,tr)');
	create_arc(result, pRoles, tFailDiscover, '(C,R,condv1,condv2,condt,tr)');
	create_arc(result, tFailDiscover, pFailRoles, '(C,R,condv1,condv2,condt,tr)');
	create_arc(result, pResources, tPublishFail, '(EPR,R,v,t)');
	create_arc(result, pResources, tPublishOk, '(EPR,R,v,t)');
	create_arc(result, tResourceExpire, pExpiredResources, '(EPR,R,v,cr)');
	create_arc(result, tFailSubscribe, pExpiredResources, '(EPR1,R,v,cr)');
	create_arc(result, pExpiredResources, tFailSubscribe, '(EPR1,R,v,cr)');
	create_arc(result, pExpiredResources, tGetTimeFail, '(EPR,R,v,cr)');
	create_arc(result, tGetTimeFail, pExpiredResources, '(EPR,R,v,cr)');
	create_arc(result, pExpiredResources, tSetPropFail, '(EPR,R,v,cr)');
	create_arc(result, tSetPropFail, pExpiredResources, '(EPR,R,v,cr)');
	create_arc(result, pExpiredResources, tGetPropFail, '(EPR,R,v,cr)');
	create_arc(result, tGetPropFail, pExpiredResources, '(EPR,R,v,cr)');
	create_arc(result, pExpiredResources, tSetTimeFail, '(EPR,R,v,cr)');
	create_arc(result, tSetTimeFail, pExpiredResources, '(EPR,R,v,cr)');
	create_arc(result, pOpControl, tGetTimeFail, '1');
	create_arc(result, pOpControl, tSetPropFail, '1');
	create_arc(result, pOpControl, tGetPropFail, '1');
	create_arc(result, pOpControl, tSetTimeFail, '1');
	create_arc(result, pOpControl, tSetTime, '1');
};

mapping UML::Interaction::scenarioPage() : CPN::Page {
	name := self.name;
	
	var tuple : Tuple (start : CPN::Place, finish : CPN::Place) := self.fragment->filterInterestingEvents()->map eventsSequenceSubnet(result);
	
	var pStart := create_place(result, 'Start\nSubscription', null, '()');
	var tStart := create_trans(result, 'Acquire\nLocks');
	var tFinish := create_trans(result, 'End\nSubscription');
	create_arc(result, pStart, tStart);
	create_arc(result, tStart, tuple.start);
	create_arc(result, tuple.finish, tFinish);
	
	-- Acquire locks
	do {
		-- Clients Locks
		self.clientLifelines()->forEach(l) {
			var pClientLock := l.clientClassifier().pClientLock(result);
			create_arc(result, pClientLock, tStart, 'l');
			create_arc(result, tFinish, pClientLock, 'l');
		};
		-- Resources Locks
		self.resourcesLifelines()->forEach(l) {
			var pResourceLock := l.resource().pResourceLock(result);
			create_arc(result, pResourceLock, tStart, 'l');
			create_arc(result, tFinish, pResourceLock, 'l');
		};
	};
	
	-- Change colours of initial and final places for an easy identification
	do {	
		pStart.lineColour:= Colour16::Green;
		tFinish.lineColour := Colour16::Maroon;
	};
}

mapping PS::Subscription::subscriptionPage() : CPN::Page 
when {
	-- TODO: Remove this precondition which allows transforming models with empty triggered Interactions
	self.triggers.lifeline->size() > 0
}
{
	init {
		-- Extract some variables for later reuse
		var interaction : UML::Interaction := self.triggers;
	
		-- Initial assertions
		do {
			var numClients : Integer := interaction.lifeline.represents.type->size(); 
			var clientClassifier := interaction.lifeline[isClient()].represents.type.oclAsType(UML::Classifier)->asList()->first();
			-- The interaction MUST contain a single <<Client>> Lifeline  
			assert fatal (interaction.lifeline[isClient()].represents.type->size() = 1)
				with log ('Triggered interaction "{1}" contains {2} <<Client>> lifelines (expected exactly 1)'._format(interaction, numClients));
			-- The type associated to the <<Client>> Lifeline MUST match the <<Client>> type associated via the <<Subscription>> Stereotype 
			assert fatal (clientClassifier = self.client.base_Lifeline.represents.type)
				with log ('Declared <<Client>> type does not match the Interaction specification in "{1}"'._format(interaction));
		};
	}
	
	name := interaction.name;

	-- Transform top-level InteractionFragments that cover the Client lifeline
	var tuple : Tuple (start : CPN::Place, finish : CPN::Place) := interaction.fragment->filterInterestingEvents()->map eventsSequenceSubnet(result);
	-- Create all the elements in the main loop
	var pNotifications := pNotifications(result);
	var pStart := create_place(result, 'Start\n{1}'._format(interaction.name), null, '()');
	var tStart := create_trans(result);
	var pFinish := create_place(result);
	var tFinish := create_trans(result);
	var pEnd:= create_place(result, 'Finish\n{1}'._format(interaction.name));
	var tClose:= create_trans(result);
	create_arc(result, pStart, tStart);
	create_arc(result, pNotifications, tStart, '(EPR,R,C,v,cc)');
	create_arc(result, tStart, pFinish);
	create_arc(result, tStart, tuple.start);
	create_arc(result, pFinish, tFinish);
	create_arc(result, tuple.finish, tFinish);
	create_arc(result, tFinish, pEnd);
	create_arc(result, pEnd, tClose);
	create_arc(result, tClose, pStart);
	
	-- Acquire locks
	do {
		-- Clients Locks
		interaction.clientLifelines()->forEach(l) {
			var pClientLock := l.clientClassifier().pClientLock(result);
			create_arc(result, pClientLock, tStart, 'l');
			create_arc(result, tFinish, pClientLock, 'l');
		};
		-- Resources Locks
		interaction.resourcesLifelines()->forEach(l) {
			var pResourceLock := l.resource().pResourceLock(result);
			create_arc(result, pResourceLock, tStart, 'l');
			create_arc(result, tFinish, pResourceLock, 'l');
		};
	};

	-- Change colours of initial and final places for an easy identification
	do {	
		pStart.lineColour:= Colour16::Green;
		pEnd.lineColour:= Colour16::Maroon;
	};
}

/**
	Reusable mappings
**/

mapping OrderedSet(UML::InteractionFragment)::eventsSequenceSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place) {
	init {
		-- Create result Places, used to link this subnet with its caller
		result := Tuple { 
			start = create_place(_page), 
			finish = create_place(_page)
		};
	}
	var pPrev : CPN::Place := result.start;
	self->forEach(event) {
		var pEvent : Tuple (start : CPN::Place, finish : CPN::Place) := event.map eventSubnet(_page);
		var tBegining : CPN::Trans := create_trans(_page);		
		var pBegining : CPN::Place := create_place(_page);
		var tEnd : CPN::Trans := create_trans(_page);		
		var pEnd : CPN::Place := create_place(_page);
		create_arc(_page, pPrev, tBegining);
		create_arc(_page, tBegining, pEvent.start);
		create_arc(_page, tBegining, pBegining);
		create_arc(_page, pBegining, tEnd);
		create_arc(_page, pEvent.finish, tEnd);
		create_arc(_page, tEnd, pEnd);
		pPrev := pEnd;
	};
	var tFinish : CPN::Trans := create_trans(_page);		
	create_arc(_page, pPrev, tFinish);
	create_arc(_page, tFinish, result.finish);
}

mapping UML::InteractionFragment::eventSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place)
disjuncts 	UML::ExecutionSpecification::clientExecutionSpecificationSubnet, 
			UML::MessageOccurrenceSpecification::setterMessageOccurrenceSpecificationSubnet,
			UML::CombinedFragment::interactionFragmentSubnet,			
			UML::InteractionFragment::failSubnetCreation;

mapping UML::InteractionFragment::failSubnetCreation(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place) {
	assert fatal (false) with log ('Unexpected InteractionFragment kind: "{1}"'._format(self));
}

mapping UML::ExecutionSpecification::clientExecutionSpecificationSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place) {
	init {
		-- Initial assertions
		assert fatal (self.lifeline().isClient()) with log ('Lifeline "{1}" is not a <<Client>> Lifeline'._format(self));
		assert fatal (self.lifeline().clientClassifier() <> null) with log ('Invalid "represents" Classifier in Lifeline "{1}"'._format(self));
		assert fatal (self.assignmentExecution().assignments->notEmpty()) with log ('Empty <<AssignmentsExecutions>> for ExecutionSpecification "{1}"'._format(self));
		-- Create result Places, used to link this subnet with its caller
		result := Tuple { 
			start = create_place(_page), 
			finish = create_place(_page)
		};
	}

	-- Extract the Client classifier for reuse
	var clientClassifier := self.lifeline().clientClassifier();
	
	-- Extract the asignments
	var assignments : List(PS::AssignmentOperation) := self.assignmentExecution().assignments->asList();
	var tAssignments : List (CPN::Trans) := assignments->map clientAssignments(_page, clientClassifier);
	
	-- Build the subnet using the created Transitions for the assignments
	var pPrev : CPN::Place := result.start;  
	tAssignments->forEach(t) {
		create_arc(_page, pPrev, t);
		if (t = tAssignments->last()) {
			pPrev := result.finish; 
		} else {
			pPrev := create_place(_page);
		};
		create_arc(_page, t, pPrev);
	};
}

mapping PS::AssignmentOperation::clientAssignments(inout _page : CPN::Page, in clientClassifier : UML::Classifier) : CPN::Trans {
	init {
		-- Initial assertions
		assert fatal (clientClassifier.attribute.name->includes(self._property.trim())) with log ('Unable to find Property "{1}" on <<Client>> Classifier "{2}"'._format(self._property.trim(), clientClassifier));
		-- Create result Place and Transition, used to link this subnet with its caller
		result := create_trans(_page, 'ASG_{1}_'._format(self._property.trim())._addSuffixNumber());
	}
	-- Create/get the fixed Client place
	var pClient := clientClassifier.pClient(_page);
	-- Create this assignment subnet
	do {
		-- Arc between the Transition and the Client place
		-- We substitute the "clientClassifier.attribute" matching "self._property" by "self.value"
		create_arc(_page, result, pClient, clientClassifier.attribute.name->collect(s : String | if s <> self._property.trim() then s else self.value.trim() endif)->asList()->joinfields(', ', '({1}, '._format(clientClassifier.clientVarName()), ')'));
		-- Arc between the Client place and the Transition
		create_arc(_page, pClient, result, clientClassifier.attribute.name->asList()->joinfields(', ', '({1}, '._format(clientClassifier.clientVarName()), ')'));
	};
};

mapping UML::MessageOccurrenceSpecification::setterMessageOccurrenceSpecificationSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place) {
	init {
		-- Initial assertions
		assert fatal (self.message.isAbstractSetter()) with log ('Expecting a MessageOccurrenceSpecification of an <<AbstractSetter>> Message but found "{1}"'._format(self));
		assert fatal (self.message.abstractSetter().operation->notEmpty()) with log ('MessageOccurrenceSpecification <<AbstractSetter>> "{1}" has empty <<UpdateOperation>>'._format(self));
		-- Create result Places, used to link this subnet with its caller
		result := Tuple { 
			start = create_place(_page), 
			finish = create_place(_page)
		};
	}
	
	-- Extract the TimedSetter and UpdateOperation for later reuse
	var setter : PS::AbstractSetter := self.message.abstractSetter();
	var op : PS::UpdateOperation := setter.operation;

	-- Create the fixed Resource Places (Registry and Lock)	and places and transitions at the begining and the end of the subnet
	var pResourceRegistry := pResourceRegistry(_page);
	var tModifyResource := create_trans(_page, null, null, '[ R = "{1}" ]'._format(setter.resource()._tag));

	-- Handle Delayed messages
	if (self.message.isDelayed()) {
		-- If the Message is Delayed (i.e., it is necessary to wait for some time)
		-- We need to include a timed transition before the Resource is updated
		var delayed := self.message.delayed();
		var tDelay := create_trans(_page, null, null, null, '@+{1}'._format(delayed.delay));
		var pDelay := create_place(_page);
		create_arc(_page, result.start, tDelay);
		create_arc(_page, tDelay, pDelay);
		create_arc(_page, pDelay, tModifyResource);
	} else {
		-- If the Message is immediate, we just link the transition at the begionin and the place at the end
		create_arc(_page, result.start, tModifyResource);
	};
	
	-- Fill all the rest of the Arcs of the core of the network
	create_arc(_page, tModifyResource, pResourceRegistry, '(EPR, R, v {1} {2}, {3})'._format(op.operator.asSymbol(), op.value, if setter.oclIsKindOf(PS::TimedSetter) then setter.oclAsType(PS::TimedSetter).time else 'cr' endif));
	create_arc(_page, pResourceRegistry, tModifyResource, '(EPR, R, v, cr)');
	create_arc(_page, tModifyResource, result.finish);
	
	-- Add places for getters, since variables may be used in the assignment
	if (self.findPreviousGetters()->notEmpty()) {
		var pResourceRegistryGetter := pResourceRegistry(_page);
		self.findPreviousGetters()->forEach(g) {
			g.variable.map asRealVariable();
		 	var pGetter := create_place(_page, resolveoneIn(real));
		 	var tGetter := create_trans(_page, null, null, '[ R = "{1}" ]'._format(g.resource._tag));
		 	create_arc(_page, pGetter, tModifyResource, g.variable);
		 	create_arc(_page, tGetter, pGetter, 'v');
		 	create_arc(_page, pGetter, tGetter, null, true);
		 	create_arc(_page, pResourceRegistryGetter, tGetter, '(EPR, R, v, cr)');
		 	create_arc(_page, tGetter, pResourceRegistryGetter, '(EPR, R, v, cr)');
		};
	}
}

mapping UML::CombinedFragment::interactionFragmentSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place)
disjuncts 	UML::CombinedFragment::altInteractionFragmentSubnet, 
			UML::CombinedFragment::parInteractionFragmentSubnet,
			UML::CombinedFragment::failSubnetCreation;

mapping UML::CombinedFragment::failSubnetCreation(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place) {
	assert fatal (false) with log ('Unexpected "interactionOperator" ({1}) in CombinedFragment "{2}"'._format(self.interactionOperator, self));
}

mapping UML::CombinedFragment::altInteractionFragmentSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place)
when {
	self.interactionOperator = UML::InteractionOperatorKind::alt
}{ 
	init {
		-- Initial assertions
		assert fatal (self.operand[guard = null]->size() <= 1)
			with log ('At most a single InteractionOperand without guard is allowed by CombinedFragment, but {1} has {2}'._format(self, self.operand[guard = null]->size()));
		-- Create result Places, used to link this subnet with its caller
		result := Tuple { 
			start = create_place(_page), 
			finish = create_place(_page)
		};
	}

	var tBegining : CPN::Trans := create_trans(_page);		
	var pBegining : CPN::Place := create_place(_page);
	
	var tNotCond : CPN::Trans := create_trans(_page, null, 'P2');
	var tNotCondEnd : CPN::Trans := create_trans(_page);
	create_arc(_page, pBegining, tNotCond);
	create_arc(_page, tNotCondEnd, result.finish);
	create_arc(_page, result.start, tBegining);
	create_arc(_page, tBegining, pBegining);

	if (self.operand[guard = null]->isEmpty()) {
		var pNotCond : CPN::Place := create_place(_page);
		create_arc(_page, tNotCond, pNotCond);
		create_arc(_page, pNotCond, tNotCondEnd);
	} else {
		var pCombinedEvents : Tuple (start : CPN::Place, finish : CPN::Place) := self.operand[guard = null]->first().fragment->filterInterestingEvents()->map eventsSequenceSubnet(_page);
		create_arc(_page, tNotCond, pCombinedEvents.start);
		create_arc(_page, pCombinedEvents.finish, tNotCondEnd);
	};
	
	self.operand[guard <> null]->forEach(o) {
		assert fatal (o.guard.constrainedElement->size() = 1)
			with log ('Expecting exactly 1 constrained element in CombinedFragment {1}, but found {2} ({3})'._format(self, o.guard.constrainedElement->size()));
		assert fatal (o.guard.constrainedElement->first().oclIsKindOf(UML::Classifier))
			with log ('Expecting a constrained element of kind UML::Classifier, but found "{1}"'._format(o.guard.constrainedElement->first()));
		assert fatal (o.guard.specification.oclIsKindOf(UML::LiteralString))
			with log ('Unexpected guard specification kind in CombinedFragment "{1}", expected a LiteralString but "{2}" found instead'._format(self, o.guard.specification));
		
		-- Saved Elements for later reuse
		var classifier : UML::Classifier := o.guard.constrainedElement->asSequence()->first().oclAsType(UML::Classifier);
		var expression : String := o.guard.specification.oclAsType(UML::LiteralString).value;
		
		var pCombinedEvents : Tuple (start : CPN::Place, finish : CPN::Place) := o.fragment->filterInterestingEvents()->map eventsSequenceSubnet(_page); 
		var pClassifier : CPN::Place := classifier.pClient(_page);
		
		var pCond : CPN::Place := create_place(_page);
		var tCond : CPN::Trans := create_trans(_page, null, 'P1', '[ {1} ]'._format(expression));
		var tCondEnd : CPN::Trans := create_trans(_page);
		create_arc(_page, pBegining, tCond);
		create_arc(_page, tCond, pCombinedEvents.start);
		create_arc(_page, pClassifier, tCond, classifier.attribute.name->asList()->joinfields(', ', '({1}, '._format(classifier.clientVarName()), ')'));
		create_arc(_page, tCond, pClassifier, classifier.attribute.name->asList()->joinfields(', ', '({1}, '._format(classifier.clientVarName()), ')'));
		create_arc(_page, tCond, pCond);
		create_arc(_page, pCombinedEvents.finish, tCondEnd);
		create_arc(_page, pCond, tCondEnd);
		create_arc(_page, tCondEnd, result.finish);

		if (self.findPreviousGetters()->notEmpty()) {
			var pResourceRegistryGetter := pResourceRegistry(_page);
			self.findPreviousGetters()->forEach(g) {
				g.variable.map asRealVariable();
			 	var pGetter := create_place(_page, resolveoneIn(real));
			 	var tGetter := create_trans(_page, null, null, '[R="{1}"]'._format(g.resource._tag));
			 	create_arc(_page, pGetter, tCond, g.variable);
			 	create_arc(_page, tGetter, pGetter, 'v');
			 	create_arc(_page, pGetter, tGetter, null, true);
			 	create_arc(_page, pResourceRegistryGetter, tGetter, '(EPR, R, v, cr)');
			 	create_arc(_page, tGetter, pResourceRegistryGetter, '(EPR, R, v, cr)');
			};
		}
	};
}

mapping UML::CombinedFragment::parInteractionFragmentSubnet(inout _page : CPN::Page) : Tuple (start : CPN::Place, finish : CPN::Place)
when {
	self.interactionOperator = UML::InteractionOperatorKind::par
}{ 
	init {
		-- Create result Places, used to link this subnet with its caller
		result := Tuple { 
			start = create_place(_page), 
			finish = create_place(_page)
		};
	}

	var tBegining : CPN::Trans := create_trans(_page);		
	var tEnd : CPN::Trans := create_trans(_page);
	create_arc(_page, result.start, tBegining);
	create_arc(_page, tEnd, result.finish);

	self.operand->forEach(o) {
		if (o.fragment->filterInterestingEvents()->isEmpty()) {
			-- Do nothing
			var pEmpty : CPN::Place:= create_place(_page, 'Empty\nOperand_'._addSuffixNumber());		
			create_arc(_page, tBegining, pEmpty);
			create_arc(_page, pEmpty, tEnd);
		} else  if (o.guard = null) {
			var pCombinedEvents : Tuple (start : CPN::Place, finish : CPN::Place) := o.fragment->filterInterestingEvents()->map eventsSequenceSubnet(_page);
			create_arc(_page, tBegining, pCombinedEvents.start);
			create_arc(_page, pCombinedEvents.finish, tEnd);
		} else {
			assert fatal (o.guard.constrainedElement->size() = 1)
				with log ('Expecting exactly 1 constrained element in CombinedFragment {1}, but found {2} ({3})'._format(self, o.guard.constrainedElement->size()));
			assert fatal (o.guard.constrainedElement->first().oclIsKindOf(UML::Classifier))
				with log ('Expecting a constrained element of kind UML::Classifier, but found "{1}"'._format(o.guard.constrainedElement->first()));
			assert fatal (o.guard.specification.oclIsKindOf(UML::LiteralString))
				with log ('Unexpected guard specification kind in CombinedFragment "{1}", expected a LiteralString but "{2}" found instead'._format(self, o.guard.specification));
			
			-- Saved Elements for later reuse
			var classifier : UML::Classifier := o.guard.constrainedElement->asSequence()->first().oclAsType(UML::Classifier);
			var expression : String := o.guard.specification.oclAsType(UML::LiteralString).value;
			
			var pCombinedEvents : Tuple (start : CPN::Place, finish : CPN::Place) := o.fragment->filterInterestingEvents()->map eventsSequenceSubnet(_page); 
			var pClassifier : CPN::Place := classifier.pClient(_page);
			
			var pBegining : CPN::Place := create_place(_page);
			var pCond : CPN::Place := create_place(_page);
			var tCond : CPN::Trans := create_trans(_page, null, null, '[ {1} ]'._format(expression));
			
			create_arc(_page, tBegining, pBegining);
			create_arc(_page, pBegining, tCond);
			create_arc(_page, tCond, pCombinedEvents.start);
			create_arc(_page, pClassifier, tCond, classifier.attribute.name->asList()->joinfields(', ', '({1}, '._format(classifier.clientVarName()), ')'));
			create_arc(_page, tCond, pClassifier, classifier.attribute.name->asList()->joinfields(', ', '({1}, '._format(classifier.clientVarName()), ')'));
			create_arc(_page, tCond, pCond);
			create_arc(_page, pCombinedEvents.finish, tEnd);
			create_arc(_page, pCond, tEnd);
	
			if (self.findPreviousGetters()->notEmpty()) {
				var pResourceRegistryGetter := pResourceRegistry(_page);
				self.findPreviousGetters()->forEach(g) {
					g.variable.map asRealVariable();
				 	var pGetter := create_place(_page, resolveoneIn(real));
				 	var tGetter := create_trans(_page, null, null, '[R="{1}"]'._format(g.resource._tag));
				 	create_arc(_page, pGetter, tCond, g.variable);
				 	create_arc(_page, tGetter, pGetter, 'v');
				 	create_arc(_page, pGetter, tGetter, null, true);
				 	create_arc(_page, pResourceRegistryGetter, tGetter, '(EPR, R, v, cr)');
				 	create_arc(_page, tGetter, pResourceRegistryGetter, '(EPR, R, v, cr)');
				};
			}
		};
	};
}


/**
	Helper to create fusions, uses a global variable "fusionCounter"
**/

property fusionCounter : Integer = 1;
helper CPN::Place::duplicate(inout _page : CPN::Page) : CPN::Place {
	var dup : CPN::Place := create_place(_page, self.text, self.type, self.initmark.expression);
	_page.places += dup;
	var fusion := self.fusion;
	if (fusion.oclIsUndefined()) {
		fusion := object CPN::Fusion {
			places += self;
			name := 'Fusion {1}'._format(fusionCounter);
			fusionCounter := fusionCounter + 1;
		};
		resolveoneIn(UML::Interaction::cpnet).fusions += fusion;
	};
	fusion.places += dup;
	return dup;
}

/**
	Helpers specific to this transformation
**/

helper UML::interaction() : UML::Interaction {
	-- TODO: Remember to comment this out in production
	return self.objectsOfKind(UML::Interaction)->select(isPublishSubscribeScenario())->asOrderedSet()->first();

	assert fatal (self.rootObjects()->size() = 1) 
		with log ('Unexpected number of input elements found: Expecting 1, but found {1}'._format(uml.rootObjects()->size()));
		
	assert fatal (self.rootObjects()->asSequence()->first().oclIsKindOf(UML::Interaction)) 
		with log ('Unexpected input element type: Expecting "UML::Interaction", but found "{1}"'._format(uml.rootObjects()->asSequence()->first().metaClassName()));
	
	var interaction : UML::Interaction = self.rootObjects()->asSequence()->first().oclAsType(UML::Interaction);
	
	assert fatal (interaction.isPublishSubscribeScenario()) 
		with log ('Root "UML::Interaction" is not a "Publish-Subscribe::PublishSubscribeScenario"');

	assert fatal (interaction.clientLifelines()->size() = 1) 
		with log ('Unexpected number of clients in "Publish-Subscribe::PublishSubscribeScenario": Expecting "1", but found "{1}"'._format(interaction.clientLifelines()->size()));
	
	return interaction;
}

/**
	Mappings for special places
**/

mapping _pResourceRegistry(inout _page : CPN::Page) : CPN::Place {
	init {
		result := create_place(_page, null, resolveoneIn(rec), null);
	}
}

helper pResourceRegistry(inout _page : CPN::Page) : CPN::Place {
	var pResourceRegistry : CPN::Place := resolveoneIn(_pResourceRegistry);
	if (pResourceRegistry.oclIsUndefined()) {
		pResourceRegistry := map _pResourceRegistry(_page);
	} else {
		pResourceRegistry := pResourceRegistry.duplicate(_page);
	};
	pResourceRegistry.text := 'Resource\nRegistry_'._addSuffixNumber();
	return pResourceRegistry; 
}

mapping _pNotifications(inout _page : CPN::Page) : CPN::Place {
	init {
		result := create_place(_page, null, resolveoneIn(cl));
	}
}

helper pNotifications(inout _page : CPN::Page) : CPN::Place {
	var pNotifications : CPN::Place := resolveoneIn(_pNotifications);
	if (pNotifications.oclIsUndefined()) {
		pNotifications := map _pNotifications(_page);
	} else {
		pNotifications := pNotifications.duplicate(_page);
	};
	pNotifications.text := 'Notifications_'._addSuffixNumber();
	return pNotifications; 
}

mapping PS::Resource::_pResourceLock(inout _page : CPN::Page) : CPN::Place {
	init {
		result := create_place(_page, null, resolveoneIn(lock), '()');
	}
}

helper PS::Resource::pResourceLock(inout _page : CPN::Page) : CPN::Place {
	var pResourceLock : CPN::Place := self.resolveoneIn(PS::Resource::_pResourceLock);
	if (pResourceLock.oclIsUndefined()) {
		pResourceLock := self.map _pResourceLock(_page);
	} else {
		pResourceLock := pResourceLock.duplicate(_page);
	};
	pResourceLock.text := '{1}_LCK_'._format(self._tag)._addSuffixNumber();
	return pResourceLock; 
}

mapping UML::Classifier::_pClient(inout _page : CPN::Page) : CPN::Place {
	init {
		var initMarking : String := self.attribute->asList().defaultValueAsString()->asList()->joinfields(', ', '("{1}", '._format(self.name.toUpperCase()), ')');
		result := create_place(_page, null, resolveone(p : CPN::Product | p.idname = self.name.toUpper()), initMarking);
	}
}

helper UML::Classifier::pClient(inout _page : CPN::Page) : CPN::Place {
	var pClient : CPN::Place := self.resolveoneIn(UML::Classifier::_pClient);
	if (pClient.oclIsUndefined()) {
		pClient := self.map _pClient(_page);
	} else {
		pClient := pClient.duplicate(_page);
	};
	pClient.text := '{1}_'._format(self.name)._addSuffixNumber();
	return pClient;
}

mapping UML::Classifier::_pClientLock(inout _page : CPN::Page) : CPN::Place {
	init {
		result := create_place(_page, null, resolveoneIn(lock), '()');
	}
}

helper UML::Classifier::pClientLock(inout _page : CPN::Page) : CPN::Place {
	var pClientLock : CPN::Place := self.resolveoneIn(UML::Classifier::_pClientLock);
	if (pClientLock.oclIsUndefined()) {
		pClientLock := self.map _pClientLock(_page);
	} else {
		pClientLock := pClientLock.duplicate(_page);
	};
	pClientLock.text := '{1}_LCK_'._format(self.name)._addSuffixNumber();
	return pClientLock;
}

